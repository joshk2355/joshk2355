import json
from difflib import get_close_matches
import re
import random
import datetime
from login import start
bot_name = 'Bot'
jokes = [
    "Why don't scientists trust atoms? Because they make up everything!",
    "I'm reading a book on anti-gravity. It's impossible to put down!",
    "Want to hear a joke about construction? I'm still working on it.",
    "What do you call fake spaghetti? An impasta!",
    "Why did the scarecrow win an award? Because he was outstanding in his field!",
    "I told my wife she was drawing her eyebrows too high. She looked surprised.",
    "Parallel lines have so much in common. It’s a shame they’ll never meet.",
    "I'm reading a book on the history of glue. I just can't seem to put it down!",
    "I used to play piano by ear, but now I use my hands.",
    "Why don't skeletons fight each other? They don't have the guts!",
    "What do you call cheese that isn't yours? Nacho cheese!",
    "I'm on a seafood diet. I see food and I eat it.",
    "Why don't eggs tell jokes? Because they'd crack each other up!",
]

# Randomly select a joke
random_joke = random.choice(jokes)


def load_knowledge_base(file_path: str) -> dict:
    with open(file_path, 'r') as file:
        data: dict = json.load(file)
    return data


def save_knowledge_base(file_path: str, data: dict):
    with open(file_path, 'w') as file:
        json.dump(data, file, indent=2)


def find_best_match(user_question: str, questions: list[str]) -> str | None:
    matches: list[str] = get_close_matches(user_question, questions, n=1, cutoff=0.6)
    return matches[0] if matches else None


def parse_math_question(user_input: str) -> tuple[str, str, str]:
    math_pattern = r'(\d+)\s*([+\-*/])\s*(\d+)'
    match = re.match(math_pattern, user_input)
    if match:
        operand1, operator, operand2 = match.groups()
        return operand1, operator, operand2
    else:
        return None


def get_answer_for_question(question: str, knowledge_base: dict) -> str | None:
    for q in knowledge_base["questions"]:
        if q["question"] == question:
            return q["answer"]
    return None


def chat_bot():
    start()
    knowledge_base: dict = load_knowledge_base('knowledge_base.json')
    global bot_name  # Add global d2eclaration
    while True:
        user_input: str = input('You: ')

        if user_input.lower() == 'quit':
            break
        if user_input.lower() == 'name bot':
            bot_name = 'chatty'
            continue
        if user_input.lower() == 'date':
            print(f"{bot_name}: Current time:", datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"))
            continue
        if user_input.lower() == 'tell me a joke':
            print(f'{bot_name}: {random_joke}')
            continue  # Skip the rest of the loop iteration

        questions = [q["question"] for q in knowledge_base["questions"]]
        best_match: str | None = find_best_match(user_input, questions)

        if best_match:
            answer: str = get_answer_for_question(best_match, knowledge_base)
            print(f'{bot_name}: {answer}')
        else:
            parsed_input = parse_math_question(user_input)
            if parsed_input:
                operand1, operator, operand2 = parsed_input
                result = eval(f"{operand1} {operator} {operand2}")
                print(f'{bot_name}: The result is {result}')
            else:
                print(f'{bot_name}: I don\'t know the answer. Can you teach me?')
                new_answer: str = input('Type the answer or "skip" to skip: ')

                if new_answer.lower() != 'skip':
                    knowledge_base["questions"].append({"question": user_input, "answer": new_answer})
                    save_knowledge_base('knowledge_base.json', knowledge_base)
                    print(f'{bot_name}: Thank you! I learned a new response!')


if __name__ == '__main__':
    chat_bot()
